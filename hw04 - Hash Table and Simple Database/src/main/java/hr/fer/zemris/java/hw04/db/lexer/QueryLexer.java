package hr.fer.zemris.java.hw04.db.lexer;

/**
 * This class performs a lexical analysis on a given database query input.
 * <p>
 * Sequences of characters will be grouped into sequence of tokens which
 * can be obtained by explicitly calling the {@link QueryLexer#nextToken()}
 * method. The supported token types are as defined in the class {@link TokenType}.
 *
 * @author Luka Čupić
 */
public class QueryLexer {

    /**
     * The sequence of input characters.
     */
    private char[] data;

    /**
     * The current token.
     */
    private Token token;

    /**
     * Index of the first non-processed character.
     */
    private int currentIndex;

    /**
     * Creates a new lexer object.
     *
     * @param data the input text to be analyzed.
     * @throws QueryLexerException if an the given input contains an illegal command.
     */
    public QueryLexer(String data) {
        if (data == null) {
            throw new IllegalArgumentException("Lexer input text cannot be null!");
        }
        this.data = data.toCharArray();
    }


    /**
     * Processes and returns the next available token.
     *
     * @return the next available token.
     * @throws QueryLexerException if an error occurs while generating a token.
     */
    public Token nextToken() throws QueryLexerException {
        // if there are no more tokens
        if (token != null && token.getType() == TokenType.EOF) {
            throw new QueryLexerException("No more tokens available!");
        }

        // token type is EOF
        if (currentIndex >= data.length) {
            // assign the global token to this type and also return it
            token = new Token(TokenType.EOF, null);
            return token;
        }

        try {
            return getNextToken();
        } catch (QueryLexerException ex) {
            throw new QueryLexerException(ex);
        } catch (Exception ex) {
            throw new QueryLexerException("An unknown error has occurred while generating the next token!");
        }
    }

    /**
     * Returns a token that was last generated by the method {@link QueryLexer#nextToken}.
     *
     * @return the last generated token or null if no tokens were previously generated.
     */
    public Token getToken() {
        return token;
    }

    /**
     * A helper method for analyzing the text and returning the next token.
     *
     * @return the next available token.
     * @throws QueryLexerException if an error occurs while generating a token.
     */
    private Token getNextToken() throws QueryLexerException {
        Token nextToken; // represents the next token which will be generated

        skipBlanks();

        // if the first character is a letter, then it's a text
        if (Character.isLetter(data[currentIndex])) {
            String text = getText();

            // check if it's a logical operator
            if ("and".equals(text.toLowerCase())) {
                nextToken = new Token(TokenType.LOGICAL_OPERATOR, text);

            // check if it's a conditional operator LIKE
            } else if ("like".equals((text.toLowerCase()))) {
                nextToken = new Token(TokenType.CONDITIONAL_OPERATOR, text);

            // if it wasn't something from above, then it's an attribute
            } else {
                nextToken = new Token(TokenType.ATTRIBUTE, text);
            }

        // if the first character is a quotation mark, then it's a string
        } else if (data[currentIndex] == '\"') {
            currentIndex++; // skip the quotation mark
            nextToken = new Token(TokenType.STRING, getString());

        // if it's nothing from above, then it could only be a conditional operator
        } else {
            int condOperator = isConditionalOperator();

            // if the operator is only one char long (e.g. <, =, >)
            if (condOperator == 1) {
                String operator = Character.toString(data[currentIndex++]);
                nextToken = new Token(TokenType.CONDITIONAL_OPERATOR, operator);

            // if the operator is two chars long (e.g. <=, !=, >=)
            } else if (condOperator == 2) {
                String operator = data[currentIndex] + "" + data[currentIndex + 1];
                currentIndex += 2;
                nextToken = new Token(TokenType.CONDITIONAL_OPERATOR, operator);

            // if if's not the operator, then it's an illegal token!
            } else {
                throw new QueryLexerException("Unrecognized token!");
            }
        }

        this.token = nextToken;
        return nextToken;
    }

    /**
     * Checks if the next token is a conditional operator.
     *
     * @return 0, 1 or 2, based on the following rules:
     * - '0' if the next token is NOT a conditional operator.
     * - '1' if the next token is a SINGLE-CHARACTER conditional operator.
     * - '2' if the next token is a DOUBLE-CHARACTER conditional operator.
     */
    private int isConditionalOperator() {
        if ("<>!".indexOf(data[currentIndex]) != -1) {
            return ("=".indexOf(data[currentIndex + 1]) != -1) ? 2 : 1;
        } else if (data[currentIndex] == '=') {
            return 1;
        }
        return 0;
    }

    /**
     * A helper method for analyzing the text and returning the next sequence of letters.
     *
     * @return the next available text token.
     */
    private String getText() {
        StringBuilder builder = new StringBuilder();

        while (currentIndex < data.length) {
            if (isEmpty(data[currentIndex]) || !Character.isLetter(data[currentIndex])) {
                break;
            }
            builder.append(data[currentIndex++]);
        }
        return builder.toString();
    }

    /**
     * A helper method for analyzing the text and returning the next string.
     *
     * @return the next available string.
     */
    private String getString() {
        StringBuilder builder = new StringBuilder();

        while (data[currentIndex] != '"') {
            builder.append(data[currentIndex++]);
        }
        currentIndex++; // skip the quotation mark

        return builder.toString();
    }

    /**
     * Skips the empty characters in {@link QueryLexer#data) starting from
     * {@link QueryLexer#currentIndex).
     * Empty characters are as defined in the {@link QueryLexer#}
     */
    private void skipBlanks() {
        while (currentIndex < data.length) {
            // keep iterating the data sequence until the current character is not "empty"
            if (!isEmpty(data[currentIndex])) break;
            currentIndex++;
        }
    }

    /**
     * Checks if the given character is "empty".
     * Empty characters include "space" and "tab".
     *
     * @return true if and only if the given character is "empty"; false otherwise.
     */
    private boolean isEmpty(char c) {
        return c == ' ' || c == '\t';
    }
}
