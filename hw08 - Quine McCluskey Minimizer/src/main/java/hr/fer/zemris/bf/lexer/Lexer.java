package hr.fer.zemris.bf.lexer;

import java.util.HashMap;
import java.util.Map;
import java.util.function.Predicate;

/**
 * Performs a lexical analysis of a sequence of characters and converts it into a
 * sequence of tokens. Acceptable tokens are defined in the {@link TokenType} class.
 * Each token's extraction is explicitly asked by calling the {@link Lexer#nextToken()}
 * method.
 *
 * @author Luka Čupić
 */
public class Lexer {

    /**
     * The sequence of input characters.
     */
    private char[] data;

    /**
     * The current token.
     */
    private Token token;

    /**
     * Index of the first non-processed character.
     */
    private int currentIndex;

    /**
     * Represents single-character tokens which are mapped
     * to their appropriate {@link TokenType}s.
     */
    private static Map<Character, TokenType> mapper;

    // initialize the mapper
    static {
        mapper = new HashMap<>();
        mapper.put('+', TokenType.OPERATOR);
        mapper.put('*', TokenType.OPERATOR);
        mapper.put('!', TokenType.OPERATOR);
        mapper.put('(', TokenType.OPEN_BRACKET);
        mapper.put(')', TokenType.CLOSED_BRACKET);
    }

    /**
     * Creates a new Lexer object and stores the input text {@code text} which
     * will be used as the sequence of characters to analyze.
     *
     * @param expression the sequence of characters to convert to tokens.
     */
    public Lexer(String expression) {
        if (expression == null) {
            throw new IllegalArgumentException("Input cannot be null.");
        }
        data = expression.toCharArray();
    }

    /**
     * Processes and returns the next available token.
     *
     * @return the next available token.
     * @throws LexerException if an error occurs while generating a token.
     */
    public Token nextToken() {
        if (token != null && token.getTokenType() == TokenType.EOF) {
            throw new LexerException("No more tokens available.");
        }

        skipBlanks();

        if (currentIndex >= data.length) {
            this.token = new Token(TokenType.EOF, null);
            return this.token;
        }

        // if token is a single character, see if it's mapped
        TokenType mappedType = mapper.get(data[currentIndex]);
        if (mappedType != null) {

            this.token = new Token(mappedType, getTokenValue(String.valueOf(data[currentIndex++])));
            return this.token;
        }

        if (Character.isLetterOrDigit(data[currentIndex])) {
            boolean isLetter = Character.isLetter(data[currentIndex]);

            // read only letters, digits and underscores
            String sequence = readSequence(this::isIdentifierChar);

            if (isLetter && !isIdentifier(sequence) || !isLetter && !isLegalNumericalValue(sequence)) {
                throw new LexerException("Illegal token!");
            }

            TokenType t = getTokenType(sequence);
            Object v = getTokenValue(sequence);

            if (isLetter) {
                if (t != null) {
                    this.token = new Token(t, v);
                } else {
                    this.token = new Token(TokenType.VARIABLE, sequence.toUpperCase());
                }
                return this.token;
            }

            // if token is a "0" or a "1", then it's okay
            if (t != null) {
                this.token = new Token(t, v);
                return this.token;
            }

            // if no matches were found, the token is illegal
            throw new LexerException("Illegal token!");

        } else {
            // read anything
            String sequence = readSequence((c) -> !isIdentifierChar(c));
            if (":+:".equals(sequence)) {
                TokenType t = getTokenType(sequence);

                // if token is not recognized, throw an exception
                if (t == null) {
                    throw new LexerException("Illegal token!");
                }

                this.token = new Token(t, getTokenValue(sequence));
                return this.token;
            }
        }

        // if no matches were found, the token is not supported
        throw new LexerException("Illegal token!");
    }

    /**
     * Returns the token that was last generated by the method {@link Lexer#nextToken}.
     * If no tokens were previously generated, the method calls {@link Lexer#nextToken}
     * and then returns the token.
     *
     * @return the last generated token
     */
    public Token getToken() {
        if (this.token == null) {
            this.token = nextToken();
        }
        return this.token;
    }

    /**
     * Reads a sequence of characters, starting from {@link Lexer#currentIndex}.
     * The method will stop reading upon encountering a character which does not
     * satisfy the given predicate, or upon reaching an "empty character".
     * See: {@link Lexer#isEmpty}.
     *
     * @param checker the predicate to delegate the verification to
     * @return the next sequence of characters read from the input sequence.
     */
    private String readSequence(Predicate<Character> checker) {
        int startIndex = currentIndex;
        currentIndex++;

        while (currentIndex < data.length) {
            if (!checker.test(data[currentIndex])) break;
            if (isEmpty(data[currentIndex])) break;
            currentIndex++;
        }
        int endIndex = currentIndex;

        return new String(data, startIndex, endIndex - startIndex);
    }

    /**
     * Returns the token type of the given sequence, if the sequence directly
     * generates a token, or null if it does not.
     *
     * @param sequence the sequence to get the token type of
     * @return the token type of the given sequence, if the sequence generates
     * a token; null otherwise
     */
    private TokenType getTokenType(String sequence) {
        switch (sequence.toLowerCase()) {
            case "and":
            case "or":
            case "not":
            case "xor":
            case ":+:":
                return TokenType.OPERATOR;
            case "true":
            case "1":
            case "false":
            case "0":
                return TokenType.CONSTANT;
            case "(":
                return TokenType.OPEN_BRACKET;
            case ")":
                return TokenType.CLOSED_BRACKET;
            default:
                return null;
        }
    }

    /**
     * Returns the token value of the given sequence, if the sequence directly
     * generates a token, or null if it does not.
     *
     * @param sequence the sequence to get the token value of
     * @return the token value of the given sequence, if the sequence generates
     * a token; null otherwise
     */
    private Object getTokenValue(String sequence) {
        switch (sequence.toLowerCase()) {
            case "and":
            case "*":
                return "and";
            case "or":
            case "+":
                return "or";
            case "not":
            case "!":
                return "not";
            case "xor":
            case ":+:":
                return "xor";
            case "true":
            case "1":
                return Boolean.TRUE;
            case "false":
            case "0":
                return Boolean.FALSE;
            case "(":
                return '(';
            case ")":
                return ')';
            default:
                return null;
        }
    }


    /**
     * Checks if the given string is an identifier. An identifier starts
     * with a letter and contains only letters, numbers and underscores.
     *
     * @param s the string to check
     * @return true if the given string is an identifier; false otherwise.
     */
    private boolean isIdentifier(String s) {
        if (s == null) {
            throw new IllegalArgumentException("Illegal argument!");
        }

        char[] chars = s.toCharArray();

        if (!Character.isLetter(chars[0])) return false;

        for (char c : chars) {
            if (isIdentifierChar(c)) continue;
            return false;
        }
        return true;
    }

    /**
     * Checks if the given character is an identifier character. A character is an
     * identifier character if it's value is either a letter, a digit or an underscore.
     *
     * @param c the character to check
     * @return true if the given character is an identifier character; false otherwise.
     */
    private boolean isIdentifierChar(Character c) {
        if (c == null) {
            throw new IllegalArgumentException("Illegal argument!");
        }

        if (Character.isLetterOrDigit(c)) return true;
        if (c == '_') return true;
        return false;

    }

    /**
     * Checks if the given string is a legal numerical value. A legal
     * value is either "0" or "1".
     *
     * @param s the string to check
     * @return true if the given string is an identifier; false otherwise.
     */
    private boolean isLegalNumericalValue(String s) {
        if ("0".equals(s)) return true;
        if ("1".equals(s)) return true;
        return false;
    }

    /**
     * Skips the empty characters in {@link Lexer#data} starting from currentIndex.
     * "Empty character" is defined in the {@link Lexer#isEmpty(char)} method.
     */
    private void skipBlanks() {
        while (currentIndex < data.length) {
            if (!isEmpty(data[currentIndex])) break;
            currentIndex++;
        }
    }

    /**
     * Checks if the given character is "empty". Empty characters include
     * "space", "tab", "carriage return" and "line feed".
     *
     * @param c the character to check
     * @return true if the character is empty; false otherwise
     */
    private boolean isEmpty(char c) {
        if (c == ' ') return true;
        if (c == '\t') return true;
        if (c == '\n') return true;
        if (c == '\r') return true;
        return false;
    }
}